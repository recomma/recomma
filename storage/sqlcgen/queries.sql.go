// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlcgen

import (
	"context"
)

const appendHyperliquidModify = `-- name: AppendHyperliquidModify :exec
INSERT INTO hyperliquid_submissions (
    venue_id,
    wallet,
    order_id,
    action_kind,
    create_payload,
    modify_payloads,
    cancel_payload,
    payload_type,
    payload_blob,
    updated_at_utc,
    botevent_row_id
) VALUES (
    ?1,
    ?2,
    ?3,
    'modify',
    NULL,
    json_array(json(?4)),
    NULL,
    ?5,
    ?6,
    CAST(unixepoch('now','subsec') * 1000 AS INTEGER),
    ?7
)
ON CONFLICT(venue_id, wallet, order_id) DO UPDATE SET
    order_id = excluded.order_id,
    modify_payloads = json_insert(
        COALESCE(hyperliquid_submissions.modify_payloads, CAST('[]' AS BLOB)),
        '$[#]',
        json(json_extract(excluded.modify_payloads, '$[0]'))
    ),
    action_kind    = 'modify',
    payload_type   = excluded.payload_type,
    payload_blob   = excluded.payload_blob,
    updated_at_utc = CAST(unixepoch('now','subsec') * 1000 AS INTEGER)
`

type AppendHyperliquidModifyParams struct {
	VenueID       string      `json:"venue_id"`
	Wallet        string      `json:"wallet"`
	OrderID       string      `json:"order_id"`
	ModifyPayload interface{} `json:"modify_payload"`
	PayloadType   string      `json:"payload_type"`
	PayloadBlob   []byte      `json:"payload_blob"`
	BoteventRowID int64       `json:"botevent_row_id"`
}

func (q *Queries) AppendHyperliquidModify(ctx context.Context, arg AppendHyperliquidModifyParams) error {
	_, err := q.db.ExecContext(ctx, appendHyperliquidModify,
		arg.VenueID,
		arg.Wallet,
		arg.OrderID,
		arg.ModifyPayload,
		arg.PayloadType,
		arg.PayloadBlob,
		arg.BoteventRowID,
	)
	return err
}

const cloneHyperliquidStatusesToWallet = `-- name: CloneHyperliquidStatusesToWallet :exec
INSERT INTO hyperliquid_status_history (
    venue_id,
    wallet,
    order_id,
    payload_type,
    payload_blob,
    recorded_at_utc
)
SELECT
    src.venue_id,
    ?1 AS wallet,
    src.order_id,
    src.payload_type,
    src.payload_blob,
    src.recorded_at_utc
FROM hyperliquid_status_history AS src
WHERE src.venue_id = ?2
  AND src.wallet = ?3
ON CONFLICT(venue_id, wallet, order_id, recorded_at_utc) DO NOTHING
`

type CloneHyperliquidStatusesToWalletParams struct {
	ToWallet   string `json:"to_wallet"`
	VenueID    string `json:"venue_id"`
	FromWallet string `json:"from_wallet"`
}

func (q *Queries) CloneHyperliquidStatusesToWallet(ctx context.Context, arg CloneHyperliquidStatusesToWalletParams) error {
	_, err := q.db.ExecContext(ctx, cloneHyperliquidStatusesToWallet, arg.ToWallet, arg.VenueID, arg.FromWallet)
	return err
}

const cloneHyperliquidSubmissionsToWallet = `-- name: CloneHyperliquidSubmissionsToWallet :exec
INSERT INTO hyperliquid_submissions (
    venue_id,
    wallet,
    order_id,
    action_kind,
    create_payload,
    modify_payloads,
    cancel_payload,
    payload_type,
    payload_blob,
    updated_at_utc,
    botevent_row_id
)
SELECT
    src.venue_id,
    ?1 AS wallet,
    src.order_id,
    src.action_kind,
    src.create_payload,
    src.modify_payloads,
    src.cancel_payload,
    src.payload_type,
    src.payload_blob,
    src.updated_at_utc,
    src.botevent_row_id
FROM hyperliquid_submissions AS src
WHERE src.venue_id = ?2
  AND src.wallet = ?3
ON CONFLICT(venue_id, wallet, order_id) DO NOTHING
`

type CloneHyperliquidSubmissionsToWalletParams struct {
	ToWallet   string `json:"to_wallet"`
	VenueID    string `json:"venue_id"`
	FromWallet string `json:"from_wallet"`
}

func (q *Queries) CloneHyperliquidSubmissionsToWallet(ctx context.Context, arg CloneHyperliquidSubmissionsToWalletParams) error {
	_, err := q.db.ExecContext(ctx, cloneHyperliquidSubmissionsToWallet, arg.ToWallet, arg.VenueID, arg.FromWallet)
	return err
}

const cloneScaledOrdersToWallet = `-- name: CloneScaledOrdersToWallet :exec
INSERT INTO scaled_orders (
    venue_id, wallet, order_id, deal_id, bot_id,
    original_size, scaled_size, multiplier, rounding_delta,
    stack_index, order_side, multiplier_updated_by,
    created_at_utc, skipped, skip_reason,
    payload_type, payload_blob
)
SELECT
    src.venue_id,
    ?1 AS wallet,
    src.order_id, src.deal_id, src.bot_id,
    src.original_size, src.scaled_size, src.multiplier, src.rounding_delta,
    src.stack_index, src.order_side, src.multiplier_updated_by,
    src.created_at_utc, src.skipped, src.skip_reason,
    src.payload_type, src.payload_blob
FROM scaled_orders AS src
WHERE src.venue_id = ?2
  AND src.wallet = ?3
ON CONFLICT(venue_id, wallet, order_id) DO NOTHING
`

type CloneScaledOrdersToWalletParams struct {
	ToWallet   string `json:"to_wallet"`
	VenueID    string `json:"venue_id"`
	FromWallet string `json:"from_wallet"`
}

func (q *Queries) CloneScaledOrdersToWallet(ctx context.Context, arg CloneScaledOrdersToWalletParams) error {
	_, err := q.db.ExecContext(ctx, cloneScaledOrdersToWallet, arg.ToWallet, arg.VenueID, arg.FromWallet)
	return err
}

const deleteBotOrderScaler = `-- name: DeleteBotOrderScaler :exec
DELETE FROM bot_order_scalers
WHERE bot_id = ?1
`

func (q *Queries) DeleteBotOrderScaler(ctx context.Context, botID int64) error {
	_, err := q.db.ExecContext(ctx, deleteBotOrderScaler, botID)
	return err
}

const deleteBotVenueAssignment = `-- name: DeleteBotVenueAssignment :exec
DELETE FROM bot_venue_assignments
WHERE bot_id = ?1
  AND venue_id = ?2
`

type DeleteBotVenueAssignmentParams struct {
	BotID   int64  `json:"bot_id"`
	VenueID string `json:"venue_id"`
}

func (q *Queries) DeleteBotVenueAssignment(ctx context.Context, arg DeleteBotVenueAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, deleteBotVenueAssignment, arg.BotID, arg.VenueID)
	return err
}

const deleteHyperliquidStatusesForWallet = `-- name: DeleteHyperliquidStatusesForWallet :exec
DELETE FROM hyperliquid_status_history
WHERE venue_id = ?1
  AND wallet = ?2
`

type DeleteHyperliquidStatusesForWalletParams struct {
	VenueID string `json:"venue_id"`
	Wallet  string `json:"wallet"`
}

func (q *Queries) DeleteHyperliquidStatusesForWallet(ctx context.Context, arg DeleteHyperliquidStatusesForWalletParams) error {
	_, err := q.db.ExecContext(ctx, deleteHyperliquidStatusesForWallet, arg.VenueID, arg.Wallet)
	return err
}

const deleteHyperliquidSubmissionsForWallet = `-- name: DeleteHyperliquidSubmissionsForWallet :exec
DELETE FROM hyperliquid_submissions
WHERE venue_id = ?1
  AND wallet = ?2
`

type DeleteHyperliquidSubmissionsForWalletParams struct {
	VenueID string `json:"venue_id"`
	Wallet  string `json:"wallet"`
}

func (q *Queries) DeleteHyperliquidSubmissionsForWallet(ctx context.Context, arg DeleteHyperliquidSubmissionsForWalletParams) error {
	_, err := q.db.ExecContext(ctx, deleteHyperliquidSubmissionsForWallet, arg.VenueID, arg.Wallet)
	return err
}

const deleteScaledOrdersForWallet = `-- name: DeleteScaledOrdersForWallet :exec
DELETE FROM scaled_orders
WHERE venue_id = ?1
  AND wallet = ?2
`

type DeleteScaledOrdersForWalletParams struct {
	VenueID string `json:"venue_id"`
	Wallet  string `json:"wallet"`
}

func (q *Queries) DeleteScaledOrdersForWallet(ctx context.Context, arg DeleteScaledOrdersForWalletParams) error {
	_, err := q.db.ExecContext(ctx, deleteScaledOrdersForWallet, arg.VenueID, arg.Wallet)
	return err
}

const deleteVaultPayloadForUser = `-- name: DeleteVaultPayloadForUser :exec
DELETE FROM vault_payloads
WHERE user_id = ?1
`

func (q *Queries) DeleteVaultPayloadForUser(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteVaultPayloadForUser, userID)
	return err
}

const deleteVaultUserByID = `-- name: DeleteVaultUserByID :exec
DELETE FROM vault_users
WHERE id = ?1
`

func (q *Queries) DeleteVaultUserByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteVaultUserByID, id)
	return err
}

const deleteVenue = `-- name: DeleteVenue :exec
DELETE FROM venues
WHERE id = ?1
`

func (q *Queries) DeleteVenue(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteVenue, id)
	return err
}

const deleteWebauthnCredentialByID = `-- name: DeleteWebauthnCredentialByID :exec
DELETE FROM webauthn_credentials
WHERE credential_id = ?1
`

func (q *Queries) DeleteWebauthnCredentialByID(ctx context.Context, credentialID []byte) error {
	_, err := q.db.ExecContext(ctx, deleteWebauthnCredentialByID, credentialID)
	return err
}

const ensureVaultUser = `-- name: EnsureVaultUser :one

INSERT INTO vault_users (
    username
) VALUES (
    ?1
)
ON CONFLICT(username) DO UPDATE SET
    username = excluded.username
RETURNING id, username, created_at_utc
`

// Vault management
func (q *Queries) EnsureVaultUser(ctx context.Context, username string) (VaultUser, error) {
	row := q.db.QueryRowContext(ctx, ensureVaultUser, username)
	var i VaultUser
	err := row.Scan(&i.ID, &i.Username, &i.CreatedAtUtc)
	return i, err
}

const fetchBot = `-- name: FetchBot :one
SELECT payload, last_synced_utc
FROM threecommas_bots
WHERE bot_id = ?1
`

type FetchBotRow struct {
	Payload       []byte `json:"payload"`
	LastSyncedUtc int64  `json:"last_synced_utc"`
}

func (q *Queries) FetchBot(ctx context.Context, botID int64) (FetchBotRow, error) {
	row := q.db.QueryRowContext(ctx, fetchBot, botID)
	var i FetchBotRow
	err := row.Scan(&i.Payload, &i.LastSyncedUtc)
	return i, err
}

const fetchDeal = `-- name: FetchDeal :one
SELECT payload
FROM threecommas_deals
WHERE deal_id = ?1
`

func (q *Queries) FetchDeal(ctx context.Context, dealID int64) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, fetchDeal, dealID)
	var payload []byte
	err := row.Scan(&payload)
	return payload, err
}

const fetchHyperliquidSubmission = `-- name: FetchHyperliquidSubmission :one
SELECT
    order_id,
    action_kind,
    CAST(create_payload AS BLOB)  AS create_payload,
    CAST(modify_payloads AS BLOB) AS modify_payloads,
    CAST(cancel_payload AS BLOB)  AS cancel_payload,
    payload_type,
    payload_blob,
    updated_at_utc,
    botevent_row_id
FROM hyperliquid_submissions
WHERE venue_id = ?1
  AND wallet = ?2
  AND order_id = ?3
`

type FetchHyperliquidSubmissionParams struct {
	VenueID string `json:"venue_id"`
	Wallet  string `json:"wallet"`
	OrderID string `json:"order_id"`
}

type FetchHyperliquidSubmissionRow struct {
	OrderID        string `json:"order_id"`
	ActionKind     string `json:"action_kind"`
	CreatePayload  []byte `json:"create_payload"`
	ModifyPayloads []byte `json:"modify_payloads"`
	CancelPayload  []byte `json:"cancel_payload"`
	PayloadType    string `json:"payload_type"`
	PayloadBlob    []byte `json:"payload_blob"`
	UpdatedAtUtc   int64  `json:"updated_at_utc"`
	BoteventRowID  int64  `json:"botevent_row_id"`
}

func (q *Queries) FetchHyperliquidSubmission(ctx context.Context, arg FetchHyperliquidSubmissionParams) (FetchHyperliquidSubmissionRow, error) {
	row := q.db.QueryRowContext(ctx, fetchHyperliquidSubmission, arg.VenueID, arg.Wallet, arg.OrderID)
	var i FetchHyperliquidSubmissionRow
	err := row.Scan(
		&i.OrderID,
		&i.ActionKind,
		&i.CreatePayload,
		&i.ModifyPayloads,
		&i.CancelPayload,
		&i.PayloadType,
		&i.PayloadBlob,
		&i.UpdatedAtUtc,
		&i.BoteventRowID,
	)
	return i, err
}

const fetchLatestHyperliquidStatus = `-- name: FetchLatestHyperliquidStatus :one
SELECT
    payload_type,
    payload_blob
FROM hyperliquid_status_history
WHERE venue_id = ?1
  AND wallet = ?2
  AND order_id = ?3
ORDER BY recorded_at_utc DESC
LIMIT 1
`

type FetchLatestHyperliquidStatusParams struct {
	VenueID string `json:"venue_id"`
	Wallet  string `json:"wallet"`
	OrderID string `json:"order_id"`
}

type FetchLatestHyperliquidStatusRow struct {
	PayloadType string `json:"payload_type"`
	PayloadBlob []byte `json:"payload_blob"`
}

func (q *Queries) FetchLatestHyperliquidStatus(ctx context.Context, arg FetchLatestHyperliquidStatusParams) (FetchLatestHyperliquidStatusRow, error) {
	row := q.db.QueryRowContext(ctx, fetchLatestHyperliquidStatus, arg.VenueID, arg.Wallet, arg.OrderID)
	var i FetchLatestHyperliquidStatusRow
	err := row.Scan(&i.PayloadType, &i.PayloadBlob)
	return i, err
}

const fetchLatestHyperliquidStatusAnyIdentifier = `-- name: FetchLatestHyperliquidStatusAnyIdentifier :one
SELECT
    venue_id,
    wallet,
    payload_type,
    payload_blob,
    recorded_at_utc
FROM hyperliquid_status_history
WHERE order_id = ?1
ORDER BY recorded_at_utc DESC
LIMIT 1
`

type FetchLatestHyperliquidStatusAnyIdentifierRow struct {
	VenueID       string `json:"venue_id"`
	Wallet        string `json:"wallet"`
	PayloadType   string `json:"payload_type"`
	PayloadBlob   []byte `json:"payload_blob"`
	RecordedAtUtc int64  `json:"recorded_at_utc"`
}

func (q *Queries) FetchLatestHyperliquidStatusAnyIdentifier(ctx context.Context, orderID string) (FetchLatestHyperliquidStatusAnyIdentifierRow, error) {
	row := q.db.QueryRowContext(ctx, fetchLatestHyperliquidStatusAnyIdentifier, orderID)
	var i FetchLatestHyperliquidStatusAnyIdentifierRow
	err := row.Scan(
		&i.VenueID,
		&i.Wallet,
		&i.PayloadType,
		&i.PayloadBlob,
		&i.RecordedAtUtc,
	)
	return i, err
}

const fetchLatestHyperliquidSubmissionAnyIdentifier = `-- name: FetchLatestHyperliquidSubmissionAnyIdentifier :one
SELECT
    venue_id,
    wallet,
    order_id,
    action_kind,
    CAST(create_payload  AS BLOB) AS create_payload,
    CAST(modify_payloads AS BLOB) AS modify_payloads,
    CAST(cancel_payload  AS BLOB) AS cancel_payload,
    payload_type,
    payload_blob,
    updated_at_utc,
    botevent_row_id
FROM hyperliquid_submissions
WHERE order_id = ?1
ORDER BY updated_at_utc DESC
LIMIT 1
`

type FetchLatestHyperliquidSubmissionAnyIdentifierRow struct {
	VenueID        string `json:"venue_id"`
	Wallet         string `json:"wallet"`
	OrderID        string `json:"order_id"`
	ActionKind     string `json:"action_kind"`
	CreatePayload  []byte `json:"create_payload"`
	ModifyPayloads []byte `json:"modify_payloads"`
	CancelPayload  []byte `json:"cancel_payload"`
	PayloadType    string `json:"payload_type"`
	PayloadBlob    []byte `json:"payload_blob"`
	UpdatedAtUtc   int64  `json:"updated_at_utc"`
	BoteventRowID  int64  `json:"botevent_row_id"`
}

func (q *Queries) FetchLatestHyperliquidSubmissionAnyIdentifier(ctx context.Context, orderID string) (FetchLatestHyperliquidSubmissionAnyIdentifierRow, error) {
	row := q.db.QueryRowContext(ctx, fetchLatestHyperliquidSubmissionAnyIdentifier, orderID)
	var i FetchLatestHyperliquidSubmissionAnyIdentifierRow
	err := row.Scan(
		&i.VenueID,
		&i.Wallet,
		&i.OrderID,
		&i.ActionKind,
		&i.CreatePayload,
		&i.ModifyPayloads,
		&i.CancelPayload,
		&i.PayloadType,
		&i.PayloadBlob,
		&i.UpdatedAtUtc,
		&i.BoteventRowID,
	)
	return i, err
}

const fetchThreeCommasBotEvent = `-- name: FetchThreeCommasBotEvent :one
SELECT payload
FROM threecommas_botevents
WHERE order_id = ?1
ORDER BY observed_at_utc DESC, id DESC
LIMIT 1
`

func (q *Queries) FetchThreeCommasBotEvent(ctx context.Context, orderID string) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, fetchThreeCommasBotEvent, orderID)
	var payload []byte
	err := row.Scan(&payload)
	return payload, err
}

const getBotOrderScaler = `-- name: GetBotOrderScaler :one
SELECT bot_id, multiplier, notes, effective_from_utc, updated_at_utc, updated_by
FROM bot_order_scalers
WHERE bot_id = ?1
`

func (q *Queries) GetBotOrderScaler(ctx context.Context, botID int64) (BotOrderScaler, error) {
	row := q.db.QueryRowContext(ctx, getBotOrderScaler, botID)
	var i BotOrderScaler
	err := row.Scan(
		&i.BotID,
		&i.Multiplier,
		&i.Notes,
		&i.EffectiveFromUtc,
		&i.UpdatedAtUtc,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrderIdForDeal = `-- name: GetOrderIdForDeal :many
SELECT DISTINCT order_id
    FROM threecommas_botevents
    WHERE deal_id = ?
`

func (q *Queries) GetOrderIdForDeal(ctx context.Context, dealID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getOrderIdForDeal, dealID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var order_id string
		if err := rows.Scan(&order_id); err != nil {
			return nil, err
		}
		items = append(items, order_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderScaler = `-- name: GetOrderScaler :one
SELECT id, multiplier, updated_at_utc, updated_by, notes
FROM order_scalers
WHERE id = 1
`

func (q *Queries) GetOrderScaler(ctx context.Context) (OrderScaler, error) {
	row := q.db.QueryRowContext(ctx, getOrderScaler)
	var i OrderScaler
	err := row.Scan(
		&i.ID,
		&i.Multiplier,
		&i.UpdatedAtUtc,
		&i.UpdatedBy,
		&i.Notes,
	)
	return i, err
}

const getPrimaryVenueForBot = `-- name: GetPrimaryVenueForBot :one
SELECT venue_id
FROM bot_venue_assignments
WHERE bot_id = ?1
  AND is_primary = 1
LIMIT 1
`

func (q *Queries) GetPrimaryVenueForBot(ctx context.Context, botID int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getPrimaryVenueForBot, botID)
	var venue_id string
	err := row.Scan(&venue_id)
	return venue_id, err
}

const getTPForDeal = `-- name: GetTPForDeal :one
SELECT order_id,
       botevent_id,
       created_at_utc,
       payload
FROM threecommas_botevents
WHERE deal_id = ?1
  AND json_extract(payload, '$.OrderType') = 'Take Profit'
ORDER BY created_at_utc DESC
LIMIT 1
`

type GetTPForDealRow struct {
	OrderID      string `json:"order_id"`
	BoteventID   int64  `json:"botevent_id"`
	CreatedAtUtc int64  `json:"created_at_utc"`
	Payload      []byte `json:"payload"`
}

func (q *Queries) GetTPForDeal(ctx context.Context, dealID int64) (GetTPForDealRow, error) {
	row := q.db.QueryRowContext(ctx, getTPForDeal, dealID)
	var i GetTPForDealRow
	err := row.Scan(
		&i.OrderID,
		&i.BoteventID,
		&i.CreatedAtUtc,
		&i.Payload,
	)
	return i, err
}

const getVaultPayloadForUser = `-- name: GetVaultPayloadForUser :one
SELECT
    id,
    user_id,
    version,
    ciphertext,
    nonce,
    associated_data,
    CAST(prf_params AS BLOB) AS prf_params,
    updated_at_utc
FROM vault_payloads
WHERE user_id = ?1
`

type GetVaultPayloadForUserRow struct {
	ID             int64  `json:"id"`
	UserID         int64  `json:"user_id"`
	Version        string `json:"version"`
	Ciphertext     []byte `json:"ciphertext"`
	Nonce          []byte `json:"nonce"`
	AssociatedData []byte `json:"associated_data"`
	PrfParams      []byte `json:"prf_params"`
	UpdatedAtUtc   int64  `json:"updated_at_utc"`
}

func (q *Queries) GetVaultPayloadForUser(ctx context.Context, userID int64) (GetVaultPayloadForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getVaultPayloadForUser, userID)
	var i GetVaultPayloadForUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Version,
		&i.Ciphertext,
		&i.Nonce,
		&i.AssociatedData,
		&i.PrfParams,
		&i.UpdatedAtUtc,
	)
	return i, err
}

const getVaultUser = `-- name: GetVaultUser :one
SELECT id, username, created_at_utc
FROM vault_users
ORDER BY id ASC
LIMIT 1
`

func (q *Queries) GetVaultUser(ctx context.Context) (VaultUser, error) {
	row := q.db.QueryRowContext(ctx, getVaultUser)
	var i VaultUser
	err := row.Scan(&i.ID, &i.Username, &i.CreatedAtUtc)
	return i, err
}

const getVaultUserByID = `-- name: GetVaultUserByID :one
SELECT id, username, created_at_utc
FROM vault_users
WHERE id = ?1
LIMIT 1
`

func (q *Queries) GetVaultUserByID(ctx context.Context, id int64) (VaultUser, error) {
	row := q.db.QueryRowContext(ctx, getVaultUserByID, id)
	var i VaultUser
	err := row.Scan(&i.ID, &i.Username, &i.CreatedAtUtc)
	return i, err
}

const getVaultUserByUsername = `-- name: GetVaultUserByUsername :one
SELECT id, username, created_at_utc
FROM vault_users
WHERE username = ?1
LIMIT 1
`

func (q *Queries) GetVaultUserByUsername(ctx context.Context, username string) (VaultUser, error) {
	row := q.db.QueryRowContext(ctx, getVaultUserByUsername, username)
	var i VaultUser
	err := row.Scan(&i.ID, &i.Username, &i.CreatedAtUtc)
	return i, err
}

const getVenue = `-- name: GetVenue :one
SELECT
    id,
    type,
    display_name,
    wallet,
    CAST(flags AS BLOB) AS flags
FROM venues
WHERE id = ?1
`

type GetVenueRow struct {
	ID          string `json:"id"`
	Type        string `json:"type"`
	DisplayName string `json:"display_name"`
	Wallet      string `json:"wallet"`
	Flags       []byte `json:"flags"`
}

func (q *Queries) GetVenue(ctx context.Context, id string) (GetVenueRow, error) {
	row := q.db.QueryRowContext(ctx, getVenue, id)
	var i GetVenueRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.DisplayName,
		&i.Wallet,
		&i.Flags,
	)
	return i, err
}

const getVenueByTypeAndWallet = `-- name: GetVenueByTypeAndWallet :one
SELECT
    id,
    type,
    display_name,
    wallet,
    CAST(flags AS BLOB) AS flags
FROM venues
WHERE type = ?1
  AND wallet = ?2
`

type GetVenueByTypeAndWalletParams struct {
	Type   string `json:"type"`
	Wallet string `json:"wallet"`
}

type GetVenueByTypeAndWalletRow struct {
	ID          string `json:"id"`
	Type        string `json:"type"`
	DisplayName string `json:"display_name"`
	Wallet      string `json:"wallet"`
	Flags       []byte `json:"flags"`
}

func (q *Queries) GetVenueByTypeAndWallet(ctx context.Context, arg GetVenueByTypeAndWalletParams) (GetVenueByTypeAndWalletRow, error) {
	row := q.db.QueryRowContext(ctx, getVenueByTypeAndWallet, arg.Type, arg.Wallet)
	var i GetVenueByTypeAndWalletRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.DisplayName,
		&i.Wallet,
		&i.Flags,
	)
	return i, err
}

const getWebauthnCredentialByID = `-- name: GetWebauthnCredentialByID :one
SELECT
    id,
    user_id,
    credential_id,
    CAST(credential AS BLOB) AS credential,
    created_at_utc,
    updated_at_utc
FROM webauthn_credentials
WHERE credential_id = ?1
`

type GetWebauthnCredentialByIDRow struct {
	ID           int64  `json:"id"`
	UserID       int64  `json:"user_id"`
	CredentialID []byte `json:"credential_id"`
	Credential   []byte `json:"credential"`
	CreatedAtUtc int64  `json:"created_at_utc"`
	UpdatedAtUtc int64  `json:"updated_at_utc"`
}

func (q *Queries) GetWebauthnCredentialByID(ctx context.Context, credentialID []byte) (GetWebauthnCredentialByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getWebauthnCredentialByID, credentialID)
	var i GetWebauthnCredentialByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CredentialID,
		&i.Credential,
		&i.CreatedAtUtc,
		&i.UpdatedAtUtc,
	)
	return i, err
}

const hasThreeCommasOrderId = `-- name: HasThreeCommasOrderId :one
SELECT EXISTS(
    SELECT 1 FROM threecommas_botevents WHERE order_id = ?1
)
`

func (q *Queries) HasThreeCommasOrderId(ctx context.Context, orderID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasThreeCommasOrderId, orderID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const insertHyperliquidStatus = `-- name: InsertHyperliquidStatus :exec
INSERT INTO hyperliquid_status_history (
    venue_id,
    wallet,
    order_id,
    payload_type,
    payload_blob,
    recorded_at_utc
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6
)
`

type InsertHyperliquidStatusParams struct {
	VenueID       string `json:"venue_id"`
	Wallet        string `json:"wallet"`
	OrderID       string `json:"order_id"`
	PayloadType   string `json:"payload_type"`
	PayloadBlob   []byte `json:"payload_blob"`
	RecordedAtUtc int64  `json:"recorded_at_utc"`
}

func (q *Queries) InsertHyperliquidStatus(ctx context.Context, arg InsertHyperliquidStatusParams) error {
	_, err := q.db.ExecContext(ctx, insertHyperliquidStatus,
		arg.VenueID,
		arg.Wallet,
		arg.OrderID,
		arg.PayloadType,
		arg.PayloadBlob,
		arg.RecordedAtUtc,
	)
	return err
}

const insertScaledOrder = `-- name: InsertScaledOrder :exec
INSERT INTO scaled_orders (
    venue_id,
    wallet,
    order_id,
    deal_id,
    bot_id,
    original_size,
    scaled_size,
    multiplier,
    rounding_delta,
    stack_index,
    order_side,
    multiplier_updated_by,
    created_at_utc,
    skipped,
    skip_reason,
    payload_type,
    payload_blob
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12,
    ?13,
    ?14,
    ?15,
    ?16,
    ?17
)
`

type InsertScaledOrderParams struct {
	VenueID             string  `json:"venue_id"`
	Wallet              string  `json:"wallet"`
	OrderID             string  `json:"order_id"`
	DealID              int64   `json:"deal_id"`
	BotID               int64   `json:"bot_id"`
	OriginalSize        float64 `json:"original_size"`
	ScaledSize          float64 `json:"scaled_size"`
	Multiplier          float64 `json:"multiplier"`
	RoundingDelta       float64 `json:"rounding_delta"`
	StackIndex          int64   `json:"stack_index"`
	OrderSide           string  `json:"order_side"`
	MultiplierUpdatedBy string  `json:"multiplier_updated_by"`
	CreatedAtUtc        int64   `json:"created_at_utc"`
	Skipped             int64   `json:"skipped"`
	SkipReason          *string `json:"skip_reason"`
	PayloadType         *string `json:"payload_type"`
	PayloadBlob         []byte  `json:"payload_blob"`
}

func (q *Queries) InsertScaledOrder(ctx context.Context, arg InsertScaledOrderParams) error {
	_, err := q.db.ExecContext(ctx, insertScaledOrder,
		arg.VenueID,
		arg.Wallet,
		arg.OrderID,
		arg.DealID,
		arg.BotID,
		arg.OriginalSize,
		arg.ScaledSize,
		arg.Multiplier,
		arg.RoundingDelta,
		arg.StackIndex,
		arg.OrderSide,
		arg.MultiplierUpdatedBy,
		arg.CreatedAtUtc,
		arg.Skipped,
		arg.SkipReason,
		arg.PayloadType,
		arg.PayloadBlob,
	)
	return err
}

const insertThreeCommasBotEvent = `-- name: InsertThreeCommasBotEvent :one
INSERT INTO threecommas_botevents (
    order_id,
    bot_id,
    deal_id,
    botevent_id,
    created_at_utc,
    payload
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6
)
ON CONFLICT(order_id, botevent_id, created_at_utc) DO NOTHING
RETURNING id
`

type InsertThreeCommasBotEventParams struct {
	OrderID      string `json:"order_id"`
	BotID        int64  `json:"bot_id"`
	DealID       int64  `json:"deal_id"`
	BoteventID   int64  `json:"botevent_id"`
	CreatedAtUtc int64  `json:"created_at_utc"`
	Payload      []byte `json:"payload"`
}

func (q *Queries) InsertThreeCommasBotEvent(ctx context.Context, arg InsertThreeCommasBotEventParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertThreeCommasBotEvent,
		arg.OrderID,
		arg.BotID,
		arg.DealID,
		arg.BoteventID,
		arg.CreatedAtUtc,
		arg.Payload,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertThreeCommasBotEventLog = `-- name: InsertThreeCommasBotEventLog :one
INSERT INTO threecommas_botevents_log (
    order_id,
    bot_id,
    deal_id,
    botevent_id,
    created_at_utc,
    payload
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6
)
ON CONFLICT(order_id, botevent_id, created_at_utc) DO NOTHING
RETURNING id
`

type InsertThreeCommasBotEventLogParams struct {
	OrderID      string `json:"order_id"`
	BotID        int64  `json:"bot_id"`
	DealID       int64  `json:"deal_id"`
	BoteventID   int64  `json:"botevent_id"`
	CreatedAtUtc int64  `json:"created_at_utc"`
	Payload      []byte `json:"payload"`
}

func (q *Queries) InsertThreeCommasBotEventLog(ctx context.Context, arg InsertThreeCommasBotEventLogParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertThreeCommasBotEventLog,
		arg.OrderID,
		arg.BotID,
		arg.DealID,
		arg.BoteventID,
		arg.CreatedAtUtc,
		arg.Payload,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listBotOrderScalers = `-- name: ListBotOrderScalers :many
SELECT bot_id, multiplier, notes, effective_from_utc, updated_at_utc, updated_by
FROM bot_order_scalers
ORDER BY bot_id ASC
`

func (q *Queries) ListBotOrderScalers(ctx context.Context) ([]BotOrderScaler, error) {
	rows, err := q.db.QueryContext(ctx, listBotOrderScalers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotOrderScaler
	for rows.Next() {
		var i BotOrderScaler
		if err := rows.Scan(
			&i.BotID,
			&i.Multiplier,
			&i.Notes,
			&i.EffectiveFromUtc,
			&i.UpdatedAtUtc,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBotVenueAssignments = `-- name: ListBotVenueAssignments :many
SELECT
    bot_id,
    venue_id,
    is_primary,
    assigned_at_utc
FROM bot_venue_assignments
WHERE bot_id = ?1
ORDER BY venue_id ASC
`

func (q *Queries) ListBotVenueAssignments(ctx context.Context, botID int64) ([]BotVenueAssignment, error) {
	rows, err := q.db.QueryContext(ctx, listBotVenueAssignments, botID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotVenueAssignment
	for rows.Next() {
		var i BotVenueAssignment
		if err := rows.Scan(
			&i.BotID,
			&i.VenueID,
			&i.IsPrimary,
			&i.AssignedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDealIDs = `-- name: ListDealIDs :many
select deal_id from threecommas_deals
`

func (q *Queries) ListDealIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listDealIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var deal_id int64
		if err := rows.Scan(&deal_id); err != nil {
			return nil, err
		}
		items = append(items, deal_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHyperliquidOrderIds = `-- name: ListHyperliquidOrderIds :many
SELECT
    venue_id,
    wallet,
    order_id,
    order_id
FROM hyperliquid_submissions
WHERE venue_id = COALESCE(?1, venue_id)
ORDER BY venue_id ASC, wallet ASC, order_id ASC
`

type ListHyperliquidOrderIdsRow struct {
	VenueID   string `json:"venue_id"`
	Wallet    string `json:"wallet"`
	OrderID   string `json:"order_id"`
	OrderID_2 string `json:"order_id_2"`
}

func (q *Queries) ListHyperliquidOrderIds(ctx context.Context, venueID string) ([]ListHyperliquidOrderIdsRow, error) {
	rows, err := q.db.QueryContext(ctx, listHyperliquidOrderIds, venueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHyperliquidOrderIdsRow
	for rows.Next() {
		var i ListHyperliquidOrderIdsRow
		if err := rows.Scan(
			&i.VenueID,
			&i.Wallet,
			&i.OrderID,
			&i.OrderID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHyperliquidStatuses = `-- name: ListHyperliquidStatuses :many
SELECT
    payload_type,
    payload_blob,
    recorded_at_utc
FROM hyperliquid_status_history
WHERE venue_id = ?1
  AND wallet = ?2
  AND order_id = ?3
ORDER BY recorded_at_utc ASC
`

type ListHyperliquidStatusesParams struct {
	VenueID string `json:"venue_id"`
	Wallet  string `json:"wallet"`
	OrderID string `json:"order_id"`
}

type ListHyperliquidStatusesRow struct {
	PayloadType   string `json:"payload_type"`
	PayloadBlob   []byte `json:"payload_blob"`
	RecordedAtUtc int64  `json:"recorded_at_utc"`
}

func (q *Queries) ListHyperliquidStatuses(ctx context.Context, arg ListHyperliquidStatusesParams) ([]ListHyperliquidStatusesRow, error) {
	rows, err := q.db.QueryContext(ctx, listHyperliquidStatuses, arg.VenueID, arg.Wallet, arg.OrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHyperliquidStatusesRow
	for rows.Next() {
		var i ListHyperliquidStatusesRow
		if err := rows.Scan(&i.PayloadType, &i.PayloadBlob, &i.RecordedAtUtc); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHyperliquidStatusesForOrderId = `-- name: ListHyperliquidStatusesForOrderId :many
SELECT
    venue_id,
    wallet,
    order_id,
    payload_type,
    payload_blob,
    recorded_at_utc
FROM hyperliquid_status_history
WHERE venue_id = ?1
  AND order_id = ?2
  AND (?3 IS NULL OR wallet = ?3)
  AND (?2 IS NULL OR order_id = ?2)
  AND recorded_at_utc >= COALESCE(?4, recorded_at_utc)
  AND recorded_at_utc <= COALESCE(?5, recorded_at_utc)
ORDER BY recorded_at_utc ASC
`

type ListHyperliquidStatusesForOrderIdParams struct {
	VenueID      string      `json:"venue_id"`
	OrderID      string      `json:"order_id"`
	Wallet       interface{} `json:"wallet"`
	ObservedFrom int64       `json:"observed_from"`
	ObservedTo   int64       `json:"observed_to"`
}

func (q *Queries) ListHyperliquidStatusesForOrderId(ctx context.Context, arg ListHyperliquidStatusesForOrderIdParams) ([]HyperliquidStatusHistory, error) {
	rows, err := q.db.QueryContext(ctx, listHyperliquidStatusesForOrderId,
		arg.VenueID,
		arg.OrderID,
		arg.Wallet,
		arg.ObservedFrom,
		arg.ObservedTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HyperliquidStatusHistory
	for rows.Next() {
		var i HyperliquidStatusHistory
		if err := rows.Scan(
			&i.VenueID,
			&i.Wallet,
			&i.OrderID,
			&i.PayloadType,
			&i.PayloadBlob,
			&i.RecordedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHyperliquidSubmissionsByOrderId = `-- name: ListHyperliquidSubmissionsByOrderId :many
SELECT
    venue_id,
    wallet,
    order_id,
    action_kind,
    CAST(create_payload AS BLOB)  AS create_payload,
    CAST(modify_payloads AS BLOB) AS modify_payloads,
    CAST(cancel_payload AS BLOB)  AS cancel_payload,
    updated_at_utc,
    botevent_row_id,
    payload_type,
    payload_blob
FROM hyperliquid_submissions
WHERE venue_id = ?1
  AND order_id IN (
    SELECT value FROM json_each(sqlc.arg(orderid_list))
)
`

type ListHyperliquidSubmissionsByOrderIdRow struct {
	VenueID        string `json:"venue_id"`
	Wallet         string `json:"wallet"`
	OrderID        string `json:"order_id"`
	ActionKind     string `json:"action_kind"`
	CreatePayload  []byte `json:"create_payload"`
	ModifyPayloads []byte `json:"modify_payloads"`
	CancelPayload  []byte `json:"cancel_payload"`
	UpdatedAtUtc   int64  `json:"updated_at_utc"`
	BoteventRowID  int64  `json:"botevent_row_id"`
	PayloadType    string `json:"payload_type"`
	PayloadBlob    []byte `json:"payload_blob"`
}

func (q *Queries) ListHyperliquidSubmissionsByOrderId(ctx context.Context, venueID string) ([]ListHyperliquidSubmissionsByOrderIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listHyperliquidSubmissionsByOrderId, venueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHyperliquidSubmissionsByOrderIdRow
	for rows.Next() {
		var i ListHyperliquidSubmissionsByOrderIdRow
		if err := rows.Scan(
			&i.VenueID,
			&i.Wallet,
			&i.OrderID,
			&i.ActionKind,
			&i.CreatePayload,
			&i.ModifyPayloads,
			&i.CancelPayload,
			&i.UpdatedAtUtc,
			&i.BoteventRowID,
			&i.PayloadType,
			&i.PayloadBlob,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLatestHyperliquidSafetyStatuses = `-- name: ListLatestHyperliquidSafetyStatuses :many
WITH ranked_status AS (
    SELECT
        venue_id,
        wallet,
        order_id,
        payload_type,
        payload_blob,
        recorded_at_utc,
        ROW_NUMBER() OVER (
            PARTITION BY venue_id, wallet, order_id
            ORDER BY recorded_at_utc DESC
        ) AS rn
    FROM hyperliquid_status_history
)
SELECT
    b.order_id AS order_id,
    b.bot_id AS bot_id,
    b.deal_id AS deal_id,
    CAST(json_extract(b.payload, '$.OrderType') AS TEXT)        AS order_type,
    CAST(json_extract(b.payload, '$.OrderPosition') AS INTEGER) AS order_position,
    CAST(json_extract(b.payload, '$.OrderSize') AS INTEGER)        AS order_size,
    latest.payload_type AS payload_type,
    latest.payload_blob AS payload_blob,
    CAST(json_extract(latest.payload_blob, '$.status') AS TEXT)            AS hl_status,
    CAST(json_extract(latest.payload_blob, '$.statusTimestamp') AS INTEGER) AS hl_status_timestamp,
    latest.recorded_at_utc AS recorded_at_utc
FROM ranked_status AS latest
JOIN hyperliquid_submissions AS s
  ON s.venue_id = latest.venue_id
 AND s.wallet = latest.wallet
 AND s.order_id = latest.order_id
JOIN threecommas_botevents AS b
  ON b.id = s.botevent_row_id
WHERE latest.rn = 1
  AND s.venue_id = ?1
  AND b.deal_id = ?2
  AND CAST(json_extract(b.payload, '$.OrderType') AS TEXT) = 'Safety'
  AND (?3 IS NULL OR latest.wallet = ?3)
ORDER BY order_position ASC
`

type ListLatestHyperliquidSafetyStatusesParams struct {
	VenueID string      `json:"venue_id"`
	DealID  int64       `json:"deal_id"`
	Wallet  interface{} `json:"wallet"`
}

type ListLatestHyperliquidSafetyStatusesRow struct {
	OrderID           string `json:"order_id"`
	BotID             int64  `json:"bot_id"`
	DealID            int64  `json:"deal_id"`
	OrderType         string `json:"order_type"`
	OrderPosition     int64  `json:"order_position"`
	OrderSize         int64  `json:"order_size"`
	PayloadType       string `json:"payload_type"`
	PayloadBlob       []byte `json:"payload_blob"`
	HlStatus          string `json:"hl_status"`
	HlStatusTimestamp int64  `json:"hl_status_timestamp"`
	RecordedAtUtc     int64  `json:"recorded_at_utc"`
}

func (q *Queries) ListLatestHyperliquidSafetyStatuses(ctx context.Context, arg ListLatestHyperliquidSafetyStatusesParams) ([]ListLatestHyperliquidSafetyStatusesRow, error) {
	rows, err := q.db.QueryContext(ctx, listLatestHyperliquidSafetyStatuses, arg.VenueID, arg.DealID, arg.Wallet)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLatestHyperliquidSafetyStatusesRow
	for rows.Next() {
		var i ListLatestHyperliquidSafetyStatusesRow
		if err := rows.Scan(
			&i.OrderID,
			&i.BotID,
			&i.DealID,
			&i.OrderType,
			&i.OrderPosition,
			&i.OrderSize,
			&i.PayloadType,
			&i.PayloadBlob,
			&i.HlStatus,
			&i.HlStatusTimestamp,
			&i.RecordedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLatestTakeProfitStackSizes = `-- name: ListLatestTakeProfitStackSizes :many
WITH ranked AS (
    SELECT
        CAST(json_extract(payload, '$.OrderPosition') AS INTEGER) AS order_position,
        CAST(json_extract(payload, '$.OrderSize') AS INTEGER) AS order_size,
        CAST(json_extract(payload, '$.Size') AS REAL) AS size,
        created_at_utc,
        id,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(json_extract(payload, '$.OrderPosition') AS INTEGER)
            ORDER BY created_at_utc DESC, id DESC
        ) AS rn
    FROM threecommas_botevents
    WHERE deal_id = ?1
      AND CAST(json_extract(payload, '$.OrderType') AS TEXT) = 'Take Profit'
      AND CAST(json_extract(payload, '$.OrderPosition') AS INTEGER) BETWEEN 0 AND CAST(?2 AS INTEGER) - 1
)
SELECT
    order_position,
    size
FROM ranked
WHERE rn = 1
ORDER BY order_position ASC
`

type ListLatestTakeProfitStackSizesParams struct {
	DealID    int64 `json:"deal_id"`
	OrderSize int64 `json:"order_size"`
}

type ListLatestTakeProfitStackSizesRow struct {
	OrderPosition int64   `json:"order_position"`
	Size          float64 `json:"size"`
}

func (q *Queries) ListLatestTakeProfitStackSizes(ctx context.Context, arg ListLatestTakeProfitStackSizesParams) ([]ListLatestTakeProfitStackSizesRow, error) {
	rows, err := q.db.QueryContext(ctx, listLatestTakeProfitStackSizes, arg.DealID, arg.OrderSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLatestTakeProfitStackSizesRow
	for rows.Next() {
		var i ListLatestTakeProfitStackSizesRow
		if err := rows.Scan(&i.OrderPosition, &i.Size); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScaledOrderAuditsForOrderId = `-- name: ListScaledOrderAuditsForOrderId :many
SELECT
    venue_id,
    wallet,
    order_id,
    deal_id,
    bot_id,
    original_size,
    scaled_size,
    multiplier,
    rounding_delta,
    stack_index,
    order_side,
    multiplier_updated_by,
    created_at_utc,
    skipped,
    skip_reason,
    payload_type,
    payload_blob
FROM scaled_orders
WHERE venue_id = ?1
  AND (
        order_id = ?2
        OR order_id LIKE ?3
    )
  AND created_at_utc >= ?4
  AND created_at_utc <= ?5
ORDER BY created_at_utc ASC, order_id ASC
`

type ListScaledOrderAuditsForOrderIdParams struct {
	VenueID       string `json:"venue_id"`
	OrderID       string `json:"order_id"`
	OrderIDPrefix string `json:"order_id_prefix"`
	ObservedFrom  int64  `json:"observed_from"`
	ObservedTo    int64  `json:"observed_to"`
}

func (q *Queries) ListScaledOrderAuditsForOrderId(ctx context.Context, arg ListScaledOrderAuditsForOrderIdParams) ([]ScaledOrder, error) {
	rows, err := q.db.QueryContext(ctx, listScaledOrderAuditsForOrderId,
		arg.VenueID,
		arg.OrderID,
		arg.OrderIDPrefix,
		arg.ObservedFrom,
		arg.ObservedTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScaledOrder
	for rows.Next() {
		var i ScaledOrder
		if err := rows.Scan(
			&i.VenueID,
			&i.Wallet,
			&i.OrderID,
			&i.DealID,
			&i.BotID,
			&i.OriginalSize,
			&i.ScaledSize,
			&i.Multiplier,
			&i.RoundingDelta,
			&i.StackIndex,
			&i.OrderSide,
			&i.MultiplierUpdatedBy,
			&i.CreatedAtUtc,
			&i.Skipped,
			&i.SkipReason,
			&i.PayloadType,
			&i.PayloadBlob,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScaledOrdersByDeal = `-- name: ListScaledOrdersByDeal :many
SELECT
    venue_id,
    wallet,
    order_id,
    deal_id,
    bot_id,
    original_size,
    scaled_size,
    multiplier,
    rounding_delta,
    stack_index,
    order_side,
    multiplier_updated_by,
    created_at_utc,
    skipped,
    skip_reason,
    payload_type,
    payload_blob
FROM scaled_orders
WHERE deal_id = ?1
ORDER BY created_at_utc ASC, order_id ASC
`

func (q *Queries) ListScaledOrdersByDeal(ctx context.Context, dealID int64) ([]ScaledOrder, error) {
	rows, err := q.db.QueryContext(ctx, listScaledOrdersByDeal, dealID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScaledOrder
	for rows.Next() {
		var i ScaledOrder
		if err := rows.Scan(
			&i.VenueID,
			&i.Wallet,
			&i.OrderID,
			&i.DealID,
			&i.BotID,
			&i.OriginalSize,
			&i.ScaledSize,
			&i.Multiplier,
			&i.RoundingDelta,
			&i.StackIndex,
			&i.OrderSide,
			&i.MultiplierUpdatedBy,
			&i.CreatedAtUtc,
			&i.Skipped,
			&i.SkipReason,
			&i.PayloadType,
			&i.PayloadBlob,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScaledOrdersByOrderId = `-- name: ListScaledOrdersByOrderId :many
SELECT
    venue_id,
    wallet,
    order_id,
    deal_id,
    bot_id,
    original_size,
    scaled_size,
    multiplier,
    rounding_delta,
    stack_index,
    order_side,
    multiplier_updated_by,
    created_at_utc,
    skipped,
    skip_reason,
    payload_type,
    payload_blob
FROM scaled_orders
WHERE order_id = ?1
   OR order_id LIKE ?2
ORDER BY created_at_utc ASC, order_id ASC
`

type ListScaledOrdersByOrderIdParams struct {
	OrderID       string `json:"order_id"`
	OrderIDPrefix string `json:"order_id_prefix"`
}

func (q *Queries) ListScaledOrdersByOrderId(ctx context.Context, arg ListScaledOrdersByOrderIdParams) ([]ScaledOrder, error) {
	rows, err := q.db.QueryContext(ctx, listScaledOrdersByOrderId, arg.OrderID, arg.OrderIDPrefix)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScaledOrder
	for rows.Next() {
		var i ScaledOrder
		if err := rows.Scan(
			&i.VenueID,
			&i.Wallet,
			&i.OrderID,
			&i.DealID,
			&i.BotID,
			&i.OriginalSize,
			&i.ScaledSize,
			&i.Multiplier,
			&i.RoundingDelta,
			&i.StackIndex,
			&i.OrderSide,
			&i.MultiplierUpdatedBy,
			&i.CreatedAtUtc,
			&i.Skipped,
			&i.SkipReason,
			&i.PayloadType,
			&i.PayloadBlob,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreeCommasBotEventLogs = `-- name: ListThreeCommasBotEventLogs :many
SELECT
    id,
    order_id,
    bot_id,
    deal_id,
    botevent_id,
    created_at_utc,
    observed_at_utc,
    payload
FROM threecommas_botevents_log
ORDER BY created_at_utc ASC, id ASC
`

func (q *Queries) ListThreeCommasBotEventLogs(ctx context.Context) ([]ThreecommasBoteventsLog, error) {
	rows, err := q.db.QueryContext(ctx, listThreeCommasBotEventLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ThreecommasBoteventsLog
	for rows.Next() {
		var i ThreecommasBoteventsLog
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.BotID,
			&i.DealID,
			&i.BoteventID,
			&i.CreatedAtUtc,
			&i.ObservedAtUtc,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreeCommasBotEventLogsForOrderId = `-- name: ListThreeCommasBotEventLogsForOrderId :many
SELECT
    id,
    order_id,
    bot_id,
    deal_id,
    botevent_id,
    created_at_utc,
    observed_at_utc,
    payload
FROM threecommas_botevents_log
WHERE order_id = ?1
  AND observed_at_utc >= COALESCE(?2, observed_at_utc)
  AND observed_at_utc <= COALESCE(?3, observed_at_utc)
ORDER BY observed_at_utc ASC, id ASC
`

type ListThreeCommasBotEventLogsForOrderIdParams struct {
	OrderID      string `json:"order_id"`
	ObservedFrom int64  `json:"observed_from"`
	ObservedTo   int64  `json:"observed_to"`
}

func (q *Queries) ListThreeCommasBotEventLogsForOrderId(ctx context.Context, arg ListThreeCommasBotEventLogsForOrderIdParams) ([]ThreecommasBoteventsLog, error) {
	rows, err := q.db.QueryContext(ctx, listThreeCommasBotEventLogsForOrderId, arg.OrderID, arg.ObservedFrom, arg.ObservedTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ThreecommasBoteventsLog
	for rows.Next() {
		var i ThreecommasBoteventsLog
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.BotID,
			&i.DealID,
			&i.BoteventID,
			&i.CreatedAtUtc,
			&i.ObservedAtUtc,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreeCommasBotEvents = `-- name: ListThreeCommasBotEvents :many
SELECT
    id,
    order_id,
    bot_id,
    deal_id,
    botevent_id,
    created_at_utc,
    observed_at_utc,
    payload
FROM threecommas_botevents
WHERE bot_id = COALESCE(?1, bot_id)
  AND deal_id = COALESCE(?2, deal_id)
  AND botevent_id = COALESCE(?3, botevent_id)
  AND observed_at_utc >= COALESCE(?4, observed_at_utc)
  AND observed_at_utc <= COALESCE(?5, observed_at_utc)
  AND (
        ?6 IS NULL
        OR LOWER(order_id) LIKE LOWER(?6) || '%'
      )
  AND (
        ?7 IS NULL
        OR observed_at_utc < ?7
        OR (
            observed_at_utc = ?7
            AND id < ?8
        )
      )
ORDER BY observed_at_utc DESC, id DESC
LIMIT ?9
`

type ListThreeCommasBotEventsParams struct {
	BotID            int64       `json:"bot_id"`
	DealID           int64       `json:"deal_id"`
	BotEventID       int64       `json:"bot_event_id"`
	ObservedFrom     int64       `json:"observed_from"`
	ObservedTo       int64       `json:"observed_to"`
	OrderIDPrefix    interface{} `json:"order_id_prefix"`
	CursorObservedAt interface{} `json:"cursor_observed_at"`
	CursorID         int64       `json:"cursor_id"`
	Limit            int64       `json:"limit"`
}

func (q *Queries) ListThreeCommasBotEvents(ctx context.Context, arg ListThreeCommasBotEventsParams) ([]ThreecommasBotevent, error) {
	rows, err := q.db.QueryContext(ctx, listThreeCommasBotEvents,
		arg.BotID,
		arg.DealID,
		arg.BotEventID,
		arg.ObservedFrom,
		arg.ObservedTo,
		arg.OrderIDPrefix,
		arg.CursorObservedAt,
		arg.CursorID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ThreecommasBotevent
	for rows.Next() {
		var i ThreecommasBotevent
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.BotID,
			&i.DealID,
			&i.BoteventID,
			&i.CreatedAtUtc,
			&i.ObservedAtUtc,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreeCommasBotEventsForOrder = `-- name: ListThreeCommasBotEventsForOrder :many
SELECT id, payload
FROM threecommas_botevents
WHERE bot_id = ?1
  AND deal_id = ?2
  AND botevent_id = ?3
ORDER BY created_at_utc ASC, observed_at_utc ASC, id ASC
`

type ListThreeCommasBotEventsForOrderParams struct {
	BotID      int64 `json:"bot_id"`
	DealID     int64 `json:"deal_id"`
	BoteventID int64 `json:"botevent_id"`
}

type ListThreeCommasBotEventsForOrderRow struct {
	ID      int64  `json:"id"`
	Payload []byte `json:"payload"`
}

func (q *Queries) ListThreeCommasBotEventsForOrder(ctx context.Context, arg ListThreeCommasBotEventsForOrderParams) ([]ListThreeCommasBotEventsForOrderRow, error) {
	rows, err := q.db.QueryContext(ctx, listThreeCommasBotEventsForOrder, arg.BotID, arg.DealID, arg.BoteventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListThreeCommasBotEventsForOrderRow
	for rows.Next() {
		var i ListThreeCommasBotEventsForOrderRow
		if err := rows.Scan(&i.ID, &i.Payload); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreeCommasBots = `-- name: ListThreeCommasBots :many

SELECT
    bot_id,
    payload,
    last_synced_utc
FROM threecommas_bots
WHERE bot_id = COALESCE(?1, bot_id)
  AND last_synced_utc >= COALESCE(?2, last_synced_utc)
  AND last_synced_utc <= COALESCE(?3, last_synced_utc)
  AND (
        ?4 IS NULL
        OR last_synced_utc < ?4
        OR (
            last_synced_utc = ?4
            AND bot_id < ?5
        )
      )
ORDER BY last_synced_utc DESC, bot_id DESC
LIMIT ?6
`

type ListThreeCommasBotsParams struct {
	BotID            int64       `json:"bot_id"`
	UpdatedFrom      int64       `json:"updated_from"`
	UpdatedTo        int64       `json:"updated_to"`
	CursorLastSynced interface{} `json:"cursor_last_synced"`
	CursorBotID      int64       `json:"cursor_bot_id"`
	Limit            int64       `json:"limit"`
}

// API specific
func (q *Queries) ListThreeCommasBots(ctx context.Context, arg ListThreeCommasBotsParams) ([]ThreecommasBot, error) {
	rows, err := q.db.QueryContext(ctx, listThreeCommasBots,
		arg.BotID,
		arg.UpdatedFrom,
		arg.UpdatedTo,
		arg.CursorLastSynced,
		arg.CursorBotID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ThreecommasBot
	for rows.Next() {
		var i ThreecommasBot
		if err := rows.Scan(&i.BotID, &i.Payload, &i.LastSyncedUtc); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreeCommasDeals = `-- name: ListThreeCommasDeals :many
SELECT
    deal_id,
    bot_id,
    created_at_utc,
    updated_at_utc,
    payload
FROM threecommas_deals
WHERE deal_id = COALESCE(?1, deal_id)
  AND bot_id = COALESCE(?2, bot_id)
  AND updated_at_utc >= COALESCE(?3, updated_at_utc)
  AND updated_at_utc <= COALESCE(?4, updated_at_utc)
  AND (
        ?5 IS NULL
        OR updated_at_utc < ?5
        OR (
            updated_at_utc = ?5
            AND deal_id < ?6
        )
      )
ORDER BY updated_at_utc DESC, deal_id DESC
LIMIT ?7
`

type ListThreeCommasDealsParams struct {
	DealID          int64       `json:"deal_id"`
	BotID           int64       `json:"bot_id"`
	UpdatedFrom     int64       `json:"updated_from"`
	UpdatedTo       int64       `json:"updated_to"`
	CursorUpdatedAt interface{} `json:"cursor_updated_at"`
	CursorDealID    int64       `json:"cursor_deal_id"`
	Limit           int64       `json:"limit"`
}

type ListThreeCommasDealsRow struct {
	DealID       int64  `json:"deal_id"`
	BotID        int64  `json:"bot_id"`
	CreatedAtUtc int64  `json:"created_at_utc"`
	UpdatedAtUtc int64  `json:"updated_at_utc"`
	Payload      []byte `json:"payload"`
}

func (q *Queries) ListThreeCommasDeals(ctx context.Context, arg ListThreeCommasDealsParams) ([]ListThreeCommasDealsRow, error) {
	rows, err := q.db.QueryContext(ctx, listThreeCommasDeals,
		arg.DealID,
		arg.BotID,
		arg.UpdatedFrom,
		arg.UpdatedTo,
		arg.CursorUpdatedAt,
		arg.CursorDealID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListThreeCommasDealsRow
	for rows.Next() {
		var i ListThreeCommasDealsRow
		if err := rows.Scan(
			&i.DealID,
			&i.BotID,
			&i.CreatedAtUtc,
			&i.UpdatedAtUtc,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVenueAssignments = `-- name: ListVenueAssignments :many
SELECT
    bot_id,
    venue_id,
    is_primary,
    assigned_at_utc
FROM bot_venue_assignments
WHERE venue_id = ?1
ORDER BY bot_id ASC
`

func (q *Queries) ListVenueAssignments(ctx context.Context, venueID string) ([]BotVenueAssignment, error) {
	rows, err := q.db.QueryContext(ctx, listVenueAssignments, venueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotVenueAssignment
	for rows.Next() {
		var i BotVenueAssignment
		if err := rows.Scan(
			&i.BotID,
			&i.VenueID,
			&i.IsPrimary,
			&i.AssignedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVenues = `-- name: ListVenues :many
SELECT
    id,
    type,
    display_name,
    wallet,
    CAST(flags AS BLOB) AS flags
FROM venues
ORDER BY id ASC
`

type ListVenuesRow struct {
	ID          string `json:"id"`
	Type        string `json:"type"`
	DisplayName string `json:"display_name"`
	Wallet      string `json:"wallet"`
	Flags       []byte `json:"flags"`
}

func (q *Queries) ListVenues(ctx context.Context) ([]ListVenuesRow, error) {
	rows, err := q.db.QueryContext(ctx, listVenues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVenuesRow
	for rows.Next() {
		var i ListVenuesRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.DisplayName,
			&i.Wallet,
			&i.Flags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebauthnCredentialsByUser = `-- name: ListWebauthnCredentialsByUser :many
SELECT
    id,
    user_id,
    credential_id,
    CAST(credential AS BLOB) AS credential,
    created_at_utc,
    updated_at_utc
FROM webauthn_credentials
WHERE user_id = ?1
ORDER BY id ASC
`

type ListWebauthnCredentialsByUserRow struct {
	ID           int64  `json:"id"`
	UserID       int64  `json:"user_id"`
	CredentialID []byte `json:"credential_id"`
	Credential   []byte `json:"credential"`
	CreatedAtUtc int64  `json:"created_at_utc"`
	UpdatedAtUtc int64  `json:"updated_at_utc"`
}

func (q *Queries) ListWebauthnCredentialsByUser(ctx context.Context, userID int64) ([]ListWebauthnCredentialsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listWebauthnCredentialsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWebauthnCredentialsByUserRow
	for rows.Next() {
		var i ListWebauthnCredentialsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CredentialID,
			&i.Credential,
			&i.CreatedAtUtc,
			&i.UpdatedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBotSync = `-- name: UpdateBotSync :exec
UPDATE threecommas_bots
SET last_synced_utc = ?1
WHERE bot_id = ?2
`

type UpdateBotSyncParams struct {
	LastSyncedUtc int64 `json:"last_synced_utc"`
	BotID         int64 `json:"bot_id"`
}

func (q *Queries) UpdateBotSync(ctx context.Context, arg UpdateBotSyncParams) error {
	_, err := q.db.ExecContext(ctx, updateBotSync, arg.LastSyncedUtc, arg.BotID)
	return err
}

const upsertBot = `-- name: UpsertBot :exec
INSERT INTO threecommas_bots (
    bot_id,
    payload,
    last_synced_utc
) VALUES (
    ?1,
    ?2,
    ?3
)
ON CONFLICT(bot_id) DO UPDATE SET
    payload = excluded.payload,
    last_synced_utc = excluded.last_synced_utc
`

type UpsertBotParams struct {
	BotID         int64  `json:"bot_id"`
	Payload       []byte `json:"payload"`
	LastSyncedUtc int64  `json:"last_synced_utc"`
}

func (q *Queries) UpsertBot(ctx context.Context, arg UpsertBotParams) error {
	_, err := q.db.ExecContext(ctx, upsertBot, arg.BotID, arg.Payload, arg.LastSyncedUtc)
	return err
}

const upsertBotOrderScaler = `-- name: UpsertBotOrderScaler :exec
INSERT INTO bot_order_scalers (
    bot_id,
    multiplier,
    notes,
    updated_by
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4
)
ON CONFLICT(bot_id) DO UPDATE SET
    multiplier     = excluded.multiplier,
    notes          = excluded.notes,
    updated_by     = excluded.updated_by,
    updated_at_utc = CAST(unixepoch('now','subsec') * 1000 AS INTEGER)
`

type UpsertBotOrderScalerParams struct {
	BotID      int64    `json:"bot_id"`
	Multiplier *float64 `json:"multiplier"`
	Notes      *string  `json:"notes"`
	UpdatedBy  string   `json:"updated_by"`
}

func (q *Queries) UpsertBotOrderScaler(ctx context.Context, arg UpsertBotOrderScalerParams) error {
	_, err := q.db.ExecContext(ctx, upsertBotOrderScaler,
		arg.BotID,
		arg.Multiplier,
		arg.Notes,
		arg.UpdatedBy,
	)
	return err
}

const upsertBotVenueAssignment = `-- name: UpsertBotVenueAssignment :exec

INSERT INTO bot_venue_assignments (
    bot_id,
    venue_id,
    is_primary
) VALUES (
    ?1,
    ?2,
    ?3
)
ON CONFLICT(bot_id, venue_id) DO UPDATE SET
    is_primary      = excluded.is_primary,
    assigned_at_utc = CAST(unixepoch('now','subsec') * 1000 AS INTEGER)
`

type UpsertBotVenueAssignmentParams struct {
	BotID     int64  `json:"bot_id"`
	VenueID   string `json:"venue_id"`
	IsPrimary int64  `json:"is_primary"`
}

// Bot-to-venue assignments
func (q *Queries) UpsertBotVenueAssignment(ctx context.Context, arg UpsertBotVenueAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, upsertBotVenueAssignment, arg.BotID, arg.VenueID, arg.IsPrimary)
	return err
}

const upsertDeal = `-- name: UpsertDeal :exec
INSERT INTO threecommas_deals (
    deal_id,
    bot_id,
    created_at_utc,
    updated_at_utc,
    payload
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5
)
ON CONFLICT(deal_id) DO UPDATE SET
    bot_id         = excluded.bot_id,
    created_at_utc = excluded.created_at_utc,
    updated_at_utc = excluded.updated_at_utc,
    payload        = excluded.payload
`

type UpsertDealParams struct {
	DealID       int64  `json:"deal_id"`
	BotID        int64  `json:"bot_id"`
	CreatedAtUtc int64  `json:"created_at_utc"`
	UpdatedAtUtc int64  `json:"updated_at_utc"`
	Payload      []byte `json:"payload"`
}

func (q *Queries) UpsertDeal(ctx context.Context, arg UpsertDealParams) error {
	_, err := q.db.ExecContext(ctx, upsertDeal,
		arg.DealID,
		arg.BotID,
		arg.CreatedAtUtc,
		arg.UpdatedAtUtc,
		arg.Payload,
	)
	return err
}

const upsertHyperliquidCancel = `-- name: UpsertHyperliquidCancel :exec
INSERT INTO hyperliquid_submissions (
    venue_id,
    wallet,
    order_id,
    action_kind,
    create_payload,
    modify_payloads,
    cancel_payload,
    payload_type,
    payload_blob,
    updated_at_utc,
    botevent_row_id
) VALUES (
    ?1,
    ?2,
    ?3,
    'cancel',
    NULL,
    '[]',
    json(?4),
    ?5,
    ?6,
    CAST(unixepoch('now','subsec') * 1000 AS INTEGER),
    ?7
)
ON CONFLICT(venue_id, wallet, order_id) DO UPDATE SET
    order_id             = excluded.order_id,
    cancel_payload = excluded.cancel_payload,
    action_kind    = 'cancel',
    payload_type   = excluded.payload_type,
    payload_blob   = excluded.payload_blob,
    updated_at_utc = CAST(unixepoch('now','subsec') * 1000 AS INTEGER)
`

type UpsertHyperliquidCancelParams struct {
	VenueID       string      `json:"venue_id"`
	Wallet        string      `json:"wallet"`
	OrderID       string      `json:"order_id"`
	CancelPayload interface{} `json:"cancel_payload"`
	PayloadType   string      `json:"payload_type"`
	PayloadBlob   []byte      `json:"payload_blob"`
	BoteventRowID int64       `json:"botevent_row_id"`
}

func (q *Queries) UpsertHyperliquidCancel(ctx context.Context, arg UpsertHyperliquidCancelParams) error {
	_, err := q.db.ExecContext(ctx, upsertHyperliquidCancel,
		arg.VenueID,
		arg.Wallet,
		arg.OrderID,
		arg.CancelPayload,
		arg.PayloadType,
		arg.PayloadBlob,
		arg.BoteventRowID,
	)
	return err
}

const upsertHyperliquidCreate = `-- name: UpsertHyperliquidCreate :exec
INSERT INTO hyperliquid_submissions (
    venue_id,
    wallet,
    order_id,
    action_kind,
    create_payload,
    modify_payloads,
    cancel_payload,
    payload_type,
    payload_blob,
    updated_at_utc,
    botevent_row_id
) VALUES (
    ?1,
    ?2,
    ?3,
    'create',
    json(?4),
    CAST('[]' AS BLOB),
    NULL,
    ?5,
    ?6,
    CAST(unixepoch('now','subsec') * 1000 AS INTEGER),
    ?7
)
ON CONFLICT(venue_id, wallet, order_id) DO UPDATE SET
    order_id             = excluded.order_id,
    create_payload = excluded.create_payload,
    action_kind    = 'create',
    payload_type   = excluded.payload_type,
    payload_blob   = excluded.payload_blob,
    updated_at_utc = CAST(unixepoch('now','subsec') * 1000 AS INTEGER)
`

type UpsertHyperliquidCreateParams struct {
	VenueID       string      `json:"venue_id"`
	Wallet        string      `json:"wallet"`
	OrderID       string      `json:"order_id"`
	CreatePayload interface{} `json:"create_payload"`
	PayloadType   string      `json:"payload_type"`
	PayloadBlob   []byte      `json:"payload_blob"`
	BoteventRowID int64       `json:"botevent_row_id"`
}

func (q *Queries) UpsertHyperliquidCreate(ctx context.Context, arg UpsertHyperliquidCreateParams) error {
	_, err := q.db.ExecContext(ctx, upsertHyperliquidCreate,
		arg.VenueID,
		arg.Wallet,
		arg.OrderID,
		arg.CreatePayload,
		arg.PayloadType,
		arg.PayloadBlob,
		arg.BoteventRowID,
	)
	return err
}

const upsertOrderScaler = `-- name: UpsertOrderScaler :exec
INSERT INTO order_scalers (
    id,
    multiplier,
    updated_by,
    notes
) VALUES (
    1,
    ?1,
    ?2,
    ?3
)
ON CONFLICT(id) DO UPDATE SET
    multiplier     = excluded.multiplier,
    updated_by     = excluded.updated_by,
    notes          = excluded.notes,
    updated_at_utc = CAST(unixepoch('now','subsec') * 1000 AS INTEGER)
`

type UpsertOrderScalerParams struct {
	Multiplier float64 `json:"multiplier"`
	UpdatedBy  string  `json:"updated_by"`
	Notes      *string `json:"notes"`
}

func (q *Queries) UpsertOrderScaler(ctx context.Context, arg UpsertOrderScalerParams) error {
	_, err := q.db.ExecContext(ctx, upsertOrderScaler, arg.Multiplier, arg.UpdatedBy, arg.Notes)
	return err
}

const upsertVaultPayload = `-- name: UpsertVaultPayload :exec
INSERT INTO vault_payloads (
    user_id,
    version,
    ciphertext,
    nonce,
    associated_data,
    prf_params,
    updated_at_utc
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    json(?6),
    ?7
)
ON CONFLICT(user_id) DO UPDATE SET
    version = excluded.version,
    ciphertext = excluded.ciphertext,
    nonce = excluded.nonce,
    associated_data = excluded.associated_data,
    prf_params = excluded.prf_params,
    updated_at_utc = excluded.updated_at_utc
`

type UpsertVaultPayloadParams struct {
	UserID         int64       `json:"user_id"`
	Version        string      `json:"version"`
	Ciphertext     []byte      `json:"ciphertext"`
	Nonce          []byte      `json:"nonce"`
	AssociatedData []byte      `json:"associated_data"`
	PrfParams      interface{} `json:"prf_params"`
	UpdatedAtUtc   int64       `json:"updated_at_utc"`
}

func (q *Queries) UpsertVaultPayload(ctx context.Context, arg UpsertVaultPayloadParams) error {
	_, err := q.db.ExecContext(ctx, upsertVaultPayload,
		arg.UserID,
		arg.Version,
		arg.Ciphertext,
		arg.Nonce,
		arg.AssociatedData,
		arg.PrfParams,
		arg.UpdatedAtUtc,
	)
	return err
}

const upsertVenue = `-- name: UpsertVenue :exec

INSERT INTO venues (
    id,
    type,
    display_name,
    wallet,
    flags
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    json(?5)
)
ON CONFLICT(id) DO UPDATE SET
    type         = excluded.type,
    display_name = excluded.display_name,
    wallet       = excluded.wallet,
    flags        = json(excluded.flags)
`

type UpsertVenueParams struct {
	ID          string      `json:"id"`
	Type        string      `json:"type"`
	DisplayName string      `json:"display_name"`
	Wallet      string      `json:"wallet"`
	Flags       interface{} `json:"flags"`
}

// Venue inventory
func (q *Queries) UpsertVenue(ctx context.Context, arg UpsertVenueParams) error {
	_, err := q.db.ExecContext(ctx, upsertVenue,
		arg.ID,
		arg.Type,
		arg.DisplayName,
		arg.Wallet,
		arg.Flags,
	)
	return err
}

const upsertWebauthnCredential = `-- name: UpsertWebauthnCredential :exec

INSERT INTO webauthn_credentials (
    user_id,
    credential_id,
    credential
) VALUES (
    ?1,
    ?2,
    json(?3)
)
ON CONFLICT(credential_id) DO UPDATE SET
    user_id = excluded.user_id,
    credential = excluded.credential,
    updated_at_utc = CAST(unixepoch('now','subsec') * 1000 AS INTEGER)
`

type UpsertWebauthnCredentialParams struct {
	UserID       int64       `json:"user_id"`
	CredentialID []byte      `json:"credential_id"`
	Credential   interface{} `json:"credential"`
}

// WebAuthn credential management
func (q *Queries) UpsertWebauthnCredential(ctx context.Context, arg UpsertWebauthnCredentialParams) error {
	_, err := q.db.ExecContext(ctx, upsertWebauthnCredential, arg.UserID, arg.CredentialID, arg.Credential)
	return err
}
