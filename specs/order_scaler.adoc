= Hyperliquid Order Scaler Specification
:toc:
:toclevels: 3

== Background & Problem Statement
3Commas bots emit deal orders sized for centralized exchanges that offer account-level leverage, grid stacking, and granular min-notional rules. Hyperliquid spot and perpetual markets expose different notional increments, fee schedules, and risk controls. Today the mirror forwards the raw 3Commas order sizes, which routinely produces submissions that:

* Violate Hyperliquid's minimum notional requirements, causing rejects or manual intervention.
* Fail to account for the desired risk posture on Hyperliquid, where operators often want tighter exposure relative to the source bot.
* Produce take-profit stacks that overwhelm the Hyperliquid emitter pacing due to unscaled granularity.

Scaling the mirrored orders before submission enables operators to tune aggregate exposure while keeping bot logic intact. The scaler must interoperate cleanly with existing deal tracking, take-profit reconciliation, and audit requirements.

== Functional Requirements
* *Global default multiplier* — Allow operators to define a repository-wide multiplier applied to every mirrored order when no more specific override exists. The multiplier must support fractional values (e.g., 0.25x) and be hot-reloadable via configuration update without a restart.
* *Per-bot overrides* — Persist optional overrides keyed by 3Commas bot ID. When present, the override multiplier replaces the global default. Overrides should inherit future global adjustments when null/empty, and deleting an override should immediately revert to the default multiplier.
* *Stack/take-profit behavior* — Apply the multiplier uniformly to initial and stacked take-profit legs generated by the deal. Rounding must preserve Hyperliquid's tick/lot requirements while keeping leg ratios identical to the source bot. When scaling would drop a leg below venue minimums, flag the deal for operator review and skip submission rather than silently discarding legs.
* *Audit logging expectations* — Emit a structured audit record whenever a scaled order is produced. The record must capture bot/deal identifiers, original size, scaled size, multiplier used, rounding adjustments, and the actor that configured the multiplier. Audit entries should surface via the existing storage event stream for downstream inspection.
* *Operator workflows* — Expose CRUD operations for the global multiplier and per-bot overrides via the HTTP API with vault authorization. Anticipate a future Web UI by returning metadata suitable for display (effective multiplier, source of configuration, last update timestamp). Provide idempotent endpoints so infrastructure-as-code tooling can manage configuration declaratively.

== Proposed Design

=== Data Model Additions
* *`order_scalers` table* — Stores the singleton global multiplier and operator metadata. Columns: `id` (PK, always 1), `multiplier` (REAL), `updated_at` (TIMESTAMP), `updated_by` (TEXT WebAuthn credential or service name).
* *`bot_order_scalers` table* — Holds per-bot overrides. Columns: `bot_id` (PK, INTEGER referencing `bots.id`), `multiplier` (REAL, nullable to allow explicit inherit?), `effective_from` (TIMESTAMP default `CURRENT_TIMESTAMP`), `updated_by` (TEXT). Include an optional `notes` field for operator context.
* *`scaled_orders` table* — Mirrors each scaled submission for audit. Columns: `id` (PK), `deal_id` (INTEGER referencing `deals.id`), `bot_id`, `original_size`, `scaled_size`, `multiplier`, `rounding_delta`, `stack_index`, `order_side`, `created_at`, `submitted_order_id` (nullable Hyperliquid order reference).

=== Engine Integration Touchpoints
* Inject the scaler into `engine` deal processing before orders reach the Hyperliquid emitter. The scaler module pulls the effective multiplier (override or global), computes scaled sizes, applies venue rounding helpers in `hl`, and emits audit entries via storage.
* Update take-profit stacking logic so scaled legs preserve ratio orderings and reuse existing `filltracker` expectations for cleanup. Ensure `filltracker` receives scaled size data for reconciliation.
* Extend emitter telemetry to include scaled size vs. executed size, enabling monitoring for divergence.

=== Storage & API Boundaries
* Extend `storage/sqlc/schema.sql` and `queries.sql` with CRUD helpers for global and per-bot multipliers, plus insertion of `scaled_orders` audit rows. Publish relevant changes via the storage stream so SSE clients can consume multiplier updates.
* Introduce API endpoints (e.g., `/v1/order-scaler` and `/v1/bots/{id}/order-scaler`) generated from `openapi.yaml`. Handlers in `internal/api` should enforce vault authorization and validate multiplier bounds (>0, <= configurable max).
* Provide read models that return the effective multiplier per bot (resolving override vs. default) to simplify UI rendering.

=== Migration Considerations
* Add a schema migration that creates the new tables and backfills the global multiplier to `1.0` with a synthetic `updated_by` (e.g., `system`). Ensure migration order preserves foreign-key constraints to `bots` and `deals`.
* For existing deals in-flight at deployment, document that they will adopt the multiplier in effect at the time of scaling; no retroactive adjustments occur.
* Coordinate schema changes with regenerated sqlc code (`go generate ./...`) and update deployment tooling to run migrations before enabling the scaler.

=== Open Questions
* How should conflicting updates (simultaneous API calls) be resolved? Consider optimistic locking or last-write-wins with audit.
* Do we need tiered multipliers per asset or side (long vs. short) beyond per-bot overrides?
* Should we expose historical multiplier changes for analytics, or is the latest value sufficient?
* What metrics/alerts should accompany the scaler to detect runaway exposure or frequent skips due to venue minimums?

== Future Work
* Implement Web UI components that surface the multiplier hierarchy and recent scaled orders.
* Explore adaptive scaling strategies that integrate Hyperliquid account margin data for dynamic multipliers.
